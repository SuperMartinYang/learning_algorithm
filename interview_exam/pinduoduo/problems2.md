# 请简述线程和进程的区别
* 进程是指一个正在运行的程序，而线程是进程内可运行的独立单元
* 每个进程拥有独立的虚拟运行空间，相互独立，而线程在进程中，单个进程中的线程共享全局变量，共享文件描述符，共享代码，共享堆，但是栈是独立的
* 多进程开支要大于多线程，因为要开辟完整的空间给一个进程，而线程只需要独立的栈空间
* 进程间通信要远远比线程间通信开支大，进程通信可以用管道，socket等，但是线程只需要用共享空间，即可交互

# 请简述抢占式和非抢占式进程的区别
* 抢占式允许暂停正在运行的可继续运行的程序，这种方法可以防止一个程序占用CPU时间过长，优化调度，同时也要多一些系统开支，例如保存当前运行程序的状态所需要的CPU开支，以及保存状态所需要的内存开支
* 非抢占式则是让程序运行结束或阻塞来调度程序

# 两个不同的线程之间如何通信？两个进程之间呢？
* 不同线程可以通过全局变量或者共享的堆空间来通信，例如pthread中提供的conditional variable， mutex之类
* 进程间通信重要通过管道，系统IPC（消息队列，信号量（semaphore），共享存储），socket进行通信

# 如何实现一个线程安全的 hash map？
* hashmap的功能主要包含了添加key-value，更新key-value，获得key-value, 删除key-value
* 线程安全是指多个线程同时访问hashmap，也不会产生conflict
* hashmap的实现方法是用array的index代表hash过后的key，value则是以链表的形式跟在key所指向的head后
* 简单的方式是对整个hashmap进行加锁（mutex_lock），访问的代码都被serialize，缺点是mutex过大，其他的线程无法访问hashmap，导致并行效率低
* 复杂的方式是针对每个操作，并不需要对整个hashmap加锁，只需要对单个的链表进行上锁，即hash过后对应的链表上锁，这样其他的线程依然可以操作其他的链表，更新或者删除，如果map到同一个链表，方才需要等待

